#include <bits/stdc++.h>
using namespace std;

typedef long long ll;

int n;
bool belonging[154321][2]
vector<int> graph[154321];
vector<int> children[154321];
int ancestor[154321][20];
int depth[154321];

bool vis[154321];

void calculateAncestors(int i) {
  int k = 1;
  while(k<20) {
    ancestor[i][k] = ancestor[ancestor[i][k-1]][k-1];
  }
}

void doRoot(int i, int depth) {
  if (vis[i]) return;
  depth[i] = depth;
  vis[i] = true;
  for (int j=0; j<graph[i]; j++) {
    int u = graph[i][j];
    children[i].push_back(u);
    ancestor[u][0] = i;
    calculateAncestors(u);
    doRoot(u, depth+1);
  }
}

int rise(int i, int d) {
  for (int k=0; k<20; k++) {
    if (d & (1<<k)) {
      i = ancestor[i][k];
    }
  }
  return i;
}

int lca(int a, int b) {
  if (! (depth[a] <= depth[b])) {
    swap(a, b);
  }
  b = rise(b, depth[b] - depth[a]);
  for (int k=20-1; k>=0; k--) {
    if (ancestor[a][k] != ancestor[b][k]) {
      a = ancestor[a][k];
      b = ancestor[b][k];
    }
  }
  a = ancestor[a][0];
  b = ancestor[b][0];
  assert(a == b && "not same ancestor??");
}

int direction[154321 * 2];
bool flatBelonging[154321 * 2][2]; // 1 -> A

int toFirstIn[154321];
int toLastIn[154321];
int toOut[154321];

int flatN;

int flatI = 0;

void flatten(int i) {
  toFirstIn[i] = flatI;
  direction[flatI] = -1;
  flatBelonging[flatI][0] = belonging[i][0];
  flatBelonging[flatI][1] = belonging[i][1];

  flatI++;

  for (int j=0; j<children[i]; j++) {
    int u = children[i][j];
    flatten(u);
    toOut[u] = flatI;
    toLastIn[i] = flatI;
    direction[flatI] = 1;

    flatI++;
  }
}






struct Monoid {
  ll numStations[2];
  ll numPathsLeft[2];
  ll numPathsRight[2];
  ll denivelation;
};

Monoid operator^(const Monoid &a, const Monoid &b) {
  Monoid res;
  res.denivelation = a.denivelation + b.denivelation;
  for (int k=0; k<2; k++) {
    res.numStations[k] = a.numStations[k] + b.numStations[k];
    res.numPathsLeft[k] = a.numPathsLeft[k] + b.numPathsLeft[k] + b.numStations[k]*a.denivelation;
    res.numPathsRight[k] = a.numPathsRight[k] + b.numPathsRight[k] + a.numStations[k]*b.denivelation;
  }
  return res;
}

Monoid singleton(int i) {
  Monoid ret;
  for (int k=0; k<2; k++) {
    ret.numStations[k] = flatBelonging[i][k];
    ret.numPathsLeft[k] = flatBelonging[i][k];
    ret.numPathsRight[k] = 0;
  }
  ret.denivelation = direction[i];
  return ret;
}

struct SegmentTree {
  int a, b;
  SegmentTree *l, *r;
  Monoid value;
  SegmentTree (int a, int b):a(a), b(b) {
    if (a == b) {
      value = singleton(a);
    } else {
      int c = (a+b)/2;
      l = new SegmentTree(a, c);
      r = new SegmentTree(c+1, b);
      value = l->value ^ r->value;
    }
  }
  void update(int i) {
    if ( i>=a && i<=b) {

    } else {
      return;
    }
  }
};

SegmentTree *tree;

void transact(int i) {


}

int main() {
  cin>>n;
  for (int i=0; i<n; i++) {
    int c;
    cin>>c;
    belonging[i][c] = true;
  }
  for(int i=0; i<n-1; i++) {
    int a,b;
    cin>>a>>b;
    graph[a].push_back(b);
    graph[b].push_back(a);
  }
  doRoot(0, 0);
  flatten(0);
  toOut[0] = flatI;
  flatI++;
  flatN = flatI;

  tree = new SegmentTree(0, flatN-1);

  int q;
  cin>>q;
  while(q--) {
    int t;
    cin>>t;
    if (t == 1) {
      int u;
      cin>>u;
      transact(u);
    } else {
      assert(t==2);
      int u,v;
      cin>>u>>v;
      compare(u,v);
    }
  }
}
